package main

// 运算符
	// 算术运算符
		// 加运算: +
		// 减运算: -
		// 乘运算: *
		// 除运算: /
		// 取余运算: %
		// 自增运算: ++
			// a++  ==  a = a + 1
		// 自减运算: --
			// 同理
	// 关系运算符 又叫 比较
		// 相等 ==
		// 不相等 !=
		// 大于 >
		// 小于 <
		// 大于等于 >
		// 小于等于 <
	// 逻辑运算符 一般是搭配条件控制(控制流使用) 结果是布尔类型
		// and  &&  // 一个& 是取指针对象  两个&& 是逻辑运算符 and
			// 有些语言(java cpp等)& - && 判断逻辑顺序 等会讲控制流(条件控制)会说
			// 逻辑and运算符表示: 当所有条件为true 结果为true 反之...
		// or   || 逻辑or 运算符: 当所有条件中 有一个为true 结果为true 反之...
		// not  ! 当条件结果为 true  !会取 反向值 false  反之...
	// 位运算符 (99% 不会打交道)
		// 左移 << 左移N位 就是乘以2的N次方
			// 因为计算机是二进制计算  0 0 0 1(1) 这个二进制 往左移动一位 0 0 1 0 (2) 往左移动一位 0 1 0 0 (4) 往左移动一位 1 0 0 0 (8)
		// 右移 >> 右移N位 就是除以2的N次方
			// 二进制的角度理解左右位移 非常简单东西
			// 1111 0000 1111 0000 1111
			// 1 1110 0001 1110 0001 1110
			// 1 1110 0001 1110 0001 1110

			// 1111 0000 1111 0000 1110
			// 0111 1000 0111 1000 0111
			// 10 + 10 = 20
			// 二进制10 + 二进制10 = 二进制 20  转换成 十进制20
		// & 位与运算符
		// | 位或运算符
		// ^ 异或运算符
	// 赋值运算符
		// = 直接赋值
			// x = 1 // int64 int32 int8 float32 float64 ... 甚至二进制 ... 定义是一定有类型的
			// var x = 1 // 有默认值 整数默认类型 int(32, 64 分别代表int32 int64), 浮点数默认类型 float64
			// var x int64 = 1
			// var x string = 1 // 错误 xxxxx
			// int x := 1 // : 自动推导符 省去编写接收类型
			// float64 x := 1.0
			// string x := ""
		// += 相加赋值
			// n := 10 int
			// i := 20 int
			// t := n + i
			// n = t 或者 i = t
			// n += i
			// n = n + i
		// -= 相减赋值
		// *= 乘赋值
		// /= 除赋值
		// %= 取余赋值
		// <<= 左位移赋值
		// >>= 右位移赋值
		// &= 位与赋值
		// |= 位或赋值
		// ^= 异赋值
		// 同理


	// ....
	// 运算优先级 可以通过 () 提升优先级  运算流从左往右 ()同理  ()里面也分优先级
	// * / % << >> & &^
	// + - | ^
	// ==  !=  <  <=  >  >=
	// &&
	// ||



// 条件控制
	// if
	/*
		if bool 类型 {

		}
		if 逻辑比较 {
			// 执行
		}
		if xxx > iii {

		}
		if true {
			// 执行
		}
		// 举个栗子 读大学
		买商品
		i := 10
		k := 20

		m := 15

		// 当我的钱能同时买i 和 k的时候执行
		// (m > i) 为true  &&  ((m - i) > k) false 结果就是false
		// (m > i) 为false &&不起作用 if控制直接就是false
		if m > i && m - i > k {
			// 2个都能买
		} else if m > k {
			// 只能买k
		} else if m > i {
			// 只能买i
		} else {
			// 什么也不买
		}
	*/
	// if else
	/*
		if 逻辑比较 {
			// 执行
		} else if 逻辑比较 {
			// 执行
		} else {
			// 执行
		}
	*/
	// switch
		/*
			// 枚举判断处理用的多
			switch 动物 {
			case 猫: // 动物是不是猫 如果是 true 不是false
				// 走逻辑
				break 中断当前 执行流
				return // 直接中断当前函数
				goto 跳出当前执行流
			case 狗:
			case 人:
			default:
				// 上面的case 全都不成立
				// 默认逻辑
			}

			switch {
			case xxx > iii:
			case kkk < zzz:
			}
		*/
	// select (Go)


	
// 循环  跳出
	/*
		break   中断当前 执行流
		return  直接中断当前函数
		goto 	跳出当前执行流
	*/
	// for bool类型 {
	//
	// }

	/*
		无限循环
		for {
			// 执行
		}
		有限循环 10次
		for i := 0; i < 10; i++ {

		}
		i := 0
		for i < 10 {
			// 执行
			i++
		}
		for i := 0; i < 10; {
			// 执行
			i++
		}
	*/
func main() {
	for i := 0; i < 10; i++ {
		if i == 5 {
			continue
		}
		// 执行
		continue // 跳过当前循环数  进行下个循环判断
		break // 退出当前循环
		return // 退出当前函数
		goto fff // 跳到指定变量执行流
		// goto 要在可见变量作用域下 才能使用
	}
	for xx > xx {
		flag := false
		for i > k {
			if xxxx {
				flag = true
				break // 只能结束内循环
			}
		}
		if flag {
			// 执行
			break
		}
	}

	// 执行N多逻辑
	fff: // flag 标记
	// 执行逻辑
	a goroutine 做了一些事件 有了结果
	b goroutine 等待a goroutine的结果 做一些事情
	channel chan // 这个是管道
	c := make(chan bool, 1)
	// 来接收a goroutine的结果
	select {
	case ret := <- c:
		_= ret
		// 处理
	}
}

func eeee() {
	for xx > xx {
		for i > k {
			if xxxx {
				goto zz
			}
		}
	}
	zz:
}
